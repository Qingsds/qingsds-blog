# 计算机网络

## TCP 与 UDP

### TCP 的三次握手

syn(synchronous 建立联机), ACK(acknowledgement 确认)

- 客户端发出请求连接 报文情况: `syn=1 ack=0 req=x`
- 服务端进行回复确认 报文情况: `syn=1 ack=1 req=y ack=x+1`
- 客户端再一次确认 报文情况: `ack=1 req=x+1 ack=y+1`

为什么是三次握手?

计算机之间的沟通需要有稳定的网络状态, 通过三次握手, 客户端和服务端都经历了一次请求和一次响应, 一方面可以确认网络状态稳定, 另一方面又确认了沟通对象既能请求也能响应, 在这样安全稳定的状态下, 两台计算机才能建立连接

### TCP 的四次回收

FIN(finish 结束)

- 客户端请求释放连接 报文情况: `FIN=1 req=x`
- 服务端进行回复确认 报文情况: `ack=1 req=y ack=x+1`
- 客户端再次发送 报文情况: `FIN=1 ack=1 req=z ack=x+1`
- 客户端确认 报文情况: `ack=1 req=x+1 ack=z+1`

为什么要四次挥手

拿离职来说 打工人:我要离职了. 公司:好的 我知道了, 我检查下你有没有什么要交接的. 公司:我检查完了你可以走了. 打工人：好的,我走了

### TCP 与 UDP 的区别

TCP 是"面向连接的可靠传输", UDP 不关心对方有没有接收到数据, 所以是不可靠连接

### UDP 的用途

在一些对实时性要求比较强的场合 比如网络电话, 视频会议, 在线直播

## HTTP

### HTTP 请求方法

- GET 发送请求获取服务器资源
- POST 向 URL 的指定资源提交数据
- PUT 修改数据请求
- DELETE 删除数据请求
- HEAD 请求页面的首部资源的信息
- options 用于跨域 列出可对资源实行的请求方法

### GET 与 POST 的区别

- 参数形式不同
  - GET 是以 query 形式附加
  - POST 是以 body 形式传递
- 参数限制
  - GET 只接受 ascii
  - POST 没限制
- 请求缓存
  - GET 主动被缓存
  - POST 需要手动
- 数据包数量不同
  - GET 产生一个 TCP 数据包
  - POST 产生两个
- 安全性 POST 比 GET 安全
- 历史记录
  - GET 会保存在历史记录
  - POST 不会

### HTTP 状态码

- 1xx 接收到请求 正在处理中
- 2xx 请求成功状态码
  - 200:成功
- 3xx 重定向状态码
  - 301: 永久重定向, 旧的资源没有了,重定向到新的资源
  - 302: 临时重定向, 旧的资源还有, 临时重定向到新的资源( 比如还没有登录的时候去操作, 重定向到登录界面)
  - 304: 重定向到缓存
- 4xx 客户端错误状态码
  - 400: 请求报文出现语法错误
  - 403: 服务器拒绝访问
  - 404: 资源不存在, 请求路径错误, 或者资源已经下掉了
- 5xx 服务器错误状态码
  - 500: 服务器接受到请求后, 发生内部错误
  - 502: 网关错误
  - 504: 网关超时

### http 缓存

#### 整体流程图

![截屏2022-02-22 21.12.18.png](https://s2.loli.net/2022/02/22/ho5xd2J3EPcDvfk.png)

- 为什么需要缓存
  - 网络请求加载比较慢 且不稳定(减少网络请求的体积和次数)
- 哪些资源可以被缓存
  - 静态资源(js css img)
- 强制缓存
  - 请求服务 服务器返回资源和 Cache-Control
  - Cache-Control
    - max-age 过期时间
    - no-cache 不用强制缓存 服务端来处理
    - no-store 不用强制缓存 服务端也不处理 直接返回资源
  - 请求流程
    - 如果该资源没有过期 直接去本地缓存(disk cache)查找
    - 资源过期了 再去请求服务端
- 协商缓存(对比缓存)
  - 服务端缓存策略(服务端判断 能够用缓存)
  - 服务端判断客户端资源 是否和服务端一样
    - 判断一致 返回 304;否则返回 200 和新资源和新资源标识
  - 流程
    - 浏览器初次请求
    - 服务器返回资源和资源标识(Last-Modified 最后修改时间或 Etag 唯一标识)
    - 浏览器再次请求携带着资源标识(request-headers 携带着 If-Modified-Since 或 If-None-Match)
      - Last-Modified 和 If-Modified-Since 名字不一样 值一样
    - 服务端判断资源标识
      - 值一样 返回 304
      - 不一样 返回资源和新的 Last-Modified 或 Etag
- 刷新操作
  - 正常操作(点击 前进 后退) => 强制缓存有效 协商缓存有效
  - 手动刷新 f5 点击刷新 右键刷新 => 强制缓存失效 协商缓存有效
  - 强制刷新 ctrl+f5 => 都失效

### HTTP 是"无状态"的理解

- 不保存上下文
  - 前后之间的请求完全没有感知,两个请求间毫无瓜葛
- 如何维持状态信息?
  - 把状态信息放在 cookie 里, 带给服务器

### HTTP 的发展历程

- 1.0
  - TCP 连接不可复用
  - 头部阻塞问题: 请求和请求之间是串行的 一个堵住了 后面的都堵住了
- 1.1
  - 实现长连接 TCP 可以复用
  - 引入管线化机制,允许请求批量提交(但仍没有解决头部阻塞问题,服务请响应仍然是串行的)
- 2.0
  - 多路复用
    - 一个连接里, 客户端和浏览器可以同时发送请求或回应, 而且不用按照顺序
  - 二进制分帧
    - 采用二进制格式的编码进行消息传输
  - 服务端推送
    - 允许服务器主动推送资源,不用经过客户端同意

### HTTP 请求过程

- 客户端进行 dns 域名解析, 得到对应的 ip 地址
- 根据这个 ip, 找到对应服务器建立连接(三次握手)
- 建立 tcp 连接后 发起 http 请求(一个完整的 http 请求报文)
- 服务器响应 http 请求, 客户端得到 html 代码
- 客户端解析 html 代码
- 服务器关闭(四次挥手)

### HTTPS

#### HTTPS 和 HTTP 的区别

- http 明文传输 https 密文传输
- http 80 端口 https 443 端口
- https 消耗的资源比 http 多

#### HTTPS 流程

- 输入 https 网址, 连接 443 端口
- 服务器将自己的数字证书(申领或自己颁发) 含公钥发送给客户端
- 客户端验证数字证书, 证书没问题, 生成秘钥, 对证书公钥加密, 将加密后的秘钥发送给服务器
- 服务端收到客户端密文, 用私钥对其解密, 用私钥对其加密,解密得到客户端发送的秘钥 key, 再用 key 对返回数据进行加密, 生成密文 VALUE, 返回给客户端
- 客户端用自己的秘钥 解密得到数据

#### 对称加密

客户端和服务端约定一个共同的"公钥",加密和解密都依赖这个公钥,一旦公钥失窃,信息就会泄漏

#### 非对称加密

公钥+私钥配合的加密手段. 公钥和私钥是多对一的关系, 公钥加密的内容只有私钥可以解开, 私钥加密的内容, 所有公钥都能解开

## 代理和反向代理

- 代理
  - 用户直到服务器地址, 但无法访问,通过代理的形式去访问
  - 特点
    - 需要通过某些软件去访问到代理服务器
    - 访问到原来访问不到的数据
    - 可以对外隐藏用户信息
- 反向代理
  - 用户不知道服务器地址, 服务器做处理, 将用户分配到子服务器
  - 特点
    - 安全
    - 负载均衡

## 安全

- xss 攻击
  - 攻击者往 web 网页里插入恶意 html 代码
  - 类型
    - 储存型 评论区
    - 反射性 qq 群分享连接
    - 文档型 注入页面 路由劫持
  - 解决
    - 对所有输入过滤
    - html 转译
    - 对于跳转连接 验证内容
    - 限制输入长度
    - http only
- csrf 攻击
  - 攻击方式
    - 自动发 GET POST
    - 利用登录状态
  - 解决
    - 检查 Referer 字段
    - 添加 token 效验
- DDOS DRDOS
  - DDOS 常见的 ping 发送 不同机器对受害者同时攻击
  - DRDOS 发送带有大量被害者 IP 的数据包给攻击主机 然后攻击主机对 IP 地址源作出大量回应 形成拒绝服务攻击
- 流量劫持
  - DNS 劫持
    - 篡改 DNS 返回不是理想的访问网址
    - 常见
      - 电脑中毒
  - http 劫持
    - 常见
      - 网站上出现不应该有的广告
    - https 可以防止
