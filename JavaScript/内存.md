# JS 内存相关知识点

## JS 内存的声明周期

JS 的生命周期和大多数编程语言一样,分三个阶段,跟农民种地的过程差不多

- "挖坑" —— 在内存空间这片广袤无垠的沃土里,划出自己的一亩三分地,此举称为 "分配内存".
- "用坑" —— 往你的一亩三分地里 "种菜" :塞入你需要存储的信息.此后你可以读取它,也可以更改它,此举称为 "内存的读与写" 操作.
- "还坑" —— 用坑一时爽,但作为好公民,咱用完这个地就得及时上交给村里.这个 "还回去" 的动作，就叫做内存的释放.

根据不同的数据来开辟不同类型的内存空间

## 栈内存和堆内存

### 引用类型和基本类型

JS 中的数据类型,整体来说只有两类:基本类型和引用类型

- 基本类型:string,number,boolean,undefined,null,Symbol.这类类型的特征:**大小固定,体积轻量,相对简单**,他们放在 JS 的栈内存中储存.
- 引用类型:比如 Object,Array,Function 等等,这类类型的特征:**数据类型比较复杂,占用空间大,且大小不定**,它们被放在 JS 的堆内存中储存.

### 图解堆与栈

#### 堆和栈是不同的数据结构,栈是线性表的一种,而堆是树形结构

实例

```js
let a = 0;
let b = "Hello World";
let c = null;
let d = { name: "修言" };
let e = ["修言", "小明", "bear"];

/*
a —— Number类型 —— 基本类型 —— 栈内存
b —— String类型 —— 基本类型 —— 栈内存
c —— null —— 基本类型 —— 栈内存
d —— Object —— 引用类型 —— 堆内存
e —— Array —— 引用类型 —— 堆内存
*/
```

内存图

![5e66f52e0001bc2711160686.png](https://s2.loli.net/2022/01/31/qLmUiSR9sKkMZur.png)
在访问 abc 变量时:直接从栈中获取值

在访问 ed 时,分两步走:

1. 从栈中获取变量对应对象的引用（即它在堆内存中的地址）
2. 拿着 1 中获取到的地址，再去堆内存空间查询，才能拿到我们想要的数据

### 垃圾回收机制

每隔一段时间,JS 的垃圾收集器就会对变量做 "巡检",当它判断一个变量不再被需要之后,它就会把这个变量所占用的内存空间给释放掉,这个过程叫做垃圾回收.
那么 JS 是如何知道一个变量是否不被需要的呢 —— 垃圾回收算法
这里主要记录两种垃圾回收算法:引用计数法和标记清除法

#### 引用计数法

这是最初级的垃圾回收算法，它在现代浏览器里几乎已经被淘汰了
在引用计数法的机制下，内存中的每一个值都会对应一个引用计数。当垃圾收集器感知到某个值的引用计数为 0 时，就判断它 “没用” 了，随即这块内存就会被释放。

引用计数法的缺点

```js
function badCycle() {
  var cycleObj1 = {};
  var cycleObj2 = {};
  cycleObj1.target = cycleObj2;
  cycleObj2.target = cycleObj1;
}

badCycle();
```

在上面代码对象互相引用的情况下,垃圾回收是识别不到`cycleObj1`和`cycleObj2`
**引用计数法无法甄别循环引用场景下得"垃圾",可能会出现内存泄漏的情况**

#### 标记清除法

在标记清除算法中,一个变量是否被需要的判断标准:**_是否可抵达_**

标记清除法的两个阶段

- 标记阶段
  - 垃圾回收器会先找到根对象,在浏览器里,根对象是`Window`,在 node 里根对象是`Global`,垃圾收集器会扫描所有可以通过根对象能触及的变量,这些变量被标记"可抵达"
- 清除阶段
  - 没有被标记"可抵达"的变量,就是不需要的变量,这些变量会被清除

### 闭包与内存泄漏

原本应该释放的变量没有被释放,一致占用着原有的内存,导致内存占用不断攀升,带来性能恶化,系统崩溃等问题,这种现象就是内存泄漏

导致内存泄漏的原因

- 意外的全局变量
- 忘记清除的 setInterval 和 setTimeout
- 清除不当的 DOM

实例

```js
//清除不当的DOM
const myDiv = document.getElementById("myDiv");
function handleMyDiv() {
  // 一些myDiv的逻辑
}
// 使用myDiv
handleMyDiv();
// 尝试删除myDiv
document.body.removeChild(document.getElementById("myDiv"));
```

### 垃圾回收相关知识点

#### 可达性

- 固有的可达值得基本集合,这些值明显不能被释放
  - 当前函数的局部变量和参数
  - 嵌套调用时,当前调用链上的所有函数的变量与参数
  - 全局变量等等
- 值 可以通过**引用**或引用链从根访问任何其他值

#### 垃圾回收算法

- 标记
  - 标记空间中的可达值
    - 从**根节点**出发 遍历所有的对象
      - 根节点
        - Window
        - Global
    - 可以遍历就是可达的
    - 没有遍历的对象,就是不可达的
- 回收
  - **不可达**的值所占据的内容
    - 多次回收对象后,内存中会存在大量**内存碎片**(不连续空间)
- 做内存整理
  - 整理内容
    - 保证内存空间足够用于后续内存的分配

#### 垃圾回收的优化方式

- 分代收集
  - 多次进行新生代的回收 少量进行老生代的回收
  - 主垃圾回收器
    - 负责
      - 老生代(v8 引擎分两个区域之一)
        - 内部对象特征
          - 占用空间大
          - 存活时间长
    - [标记 -> 清除]
      - 标记
        - 从根元素开始 遍历
        - 标记能到达的活动对象
        - 标记不能到达的为**垃圾数据**
      - 清除
        - 清除不能到达的**垃圾数据**
    - 内存碎片整理
      - 多次清除后
        - 将所有的活动对象整理 并将他们有序的排列一遍
  - 副垃圾回收器
    - 负责
      - 新生代(v8 引擎区分两个区域之一)垃圾的回收
        - 存放在临时对象(浏览器区分)
          - 存活时间短
    - 区域分布
      - 对象区
        - 新对象 加入的存放区域
        - 进行标记清除的区域
      - 空闲区
        - 可以理解成 用于存放临时变量用的
    - 执行清理垃圾的时间
      - 当**对象区**快满的时候
        - 新加入的对象都会被放入对象区
    - 执行过程
      - **对象区域** 标记清除 剩余 **存活对象**
      - 复制
        - **存活的对象** 被复制到空闲区域,并且将他们有序的排列一遍
      - 对调 对象区域和空闲区
        - 将**空闲区**中**存活对象**放到**对象区**等待下次处理
- 增量收集
  - 函数内 未定义的变量 会在全局对象中创建一个新变量
    - 例子

  ```js
  function foo(arg) {
    bar = "hello";
  }
  ```

  - 引擎将垃圾收集的工作分成更小的块,每次处理一部分,多次处理
- 闲时收集
  - 只会在CPU空闲时间尝试运行,以减少可能对代码的影响

#### 不同类型的释放时间

- 引用类型
  - 无引用被v8回收
- 值类型
  - 处于闭包
    - 要等闭包没有引用才被回收
  - 非闭包
    - 等待v8新生代切换的时候回收

#### 容易导致内存泄漏的场景

- 内存泄漏概念
  - **用不到**(访问不到)的变量,依然占据着内存空间,不能再次利用起来
- 场景
  - 意外的全局变量
    - 在非严格模式下
      - 函数内使用this 但由于this隐式丢失 导致变量挂载到了全局变量上
    - 解决方案
      - 使用严格模式
  - 被遗忘的计时器或回调函数
    - 现代浏览器更先进的垃圾回收算法可以正确的检测及处理
  - 脱离DOM的引用
    - 将DOM储存在对象或者数组中
      - 导致DOM有两个引用
        - DOM树种
        - 对象和数组中